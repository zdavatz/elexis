#!/usr/bin/ruby 
# encoding: utf-8
# Copyright 2012 by Niklaus Giger <niklaus.giger@member.fsf.org
#
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Delta pack from http://mirror.switch.ch/eclipse/eclipse/downloads/drops/R-3.7.2-201202080800/eclipse-3.7.2-delta-pack.zip
# See also http://aniefer.blogspot.com/2009/06/using-deltapack-in-eclipse-35.html
# The director is only able to install for one platform so it can't really handle the delta pack. You should instead look at using a combination of the p2.mirror and p2.repo2runnable ant tasks which don't care about the platform. 
# ./eclipse -nosplash -consolelog -application org.eclipse.equinox.p2.repository.repo2runnable \
#   -source jar:file:/home/nboldt/eclipse/35clean/GEF-Update-3.5.0RC2.zip\!/ \
#   -source GEF-Update-N200905281802/
#   -source emf-sdo-xsd-Update-2.4.2.zip
#   -source http://download.eclipse.org/tools/ve/updates/1.4
#   -destination /tmp/unpacked
require 'buildrizpack'

# we should parse Eclipse-PlatformFilter: (& (osgi.ws=win32) (osgi.os=win32) (osgi.arch= x86_64))
Java.load # needed to load class path for apache logger
#  DeployElexis = File.expand_path(File.join(project(group)._, '..', 'deploy'))
  DeployElexis = File.expand_path(File.join(Dir.pwd, 'deploy'))
  layout[:target] = DeployElexis
  ProductInfoFile = _('branding.product')

  Macosx_x86_64  =  { 'osgi.os' => 'macosx', 'osgi.ws' => 'cocoa', 'osgi.arch' => 'x86_64',
                      'executable' => '$INSTALL_PATH/elexis.app/Contents/MacOS/elexis',
                      'condition' => 'izpack.macinstall+is64bit', 
                      'description' => 'MacOSX (64-bit) abhängige Dateien'}
  Macosx_x86     =  { 'osgi.os' => 'macosx', 'osgi.ws' => 'cocoa', 'osgi.arch' => 'x86',
                      'executable' => '$INSTALL_PATH/elexis.app/Contents/MacOS/elexis',
                      'condition' => 'izpack.macinstall+is32bit', 
                      'description' => 'MacOSX (32-bit) abhängige Dateien'}
  Linux_x86_64   =  { 'osgi.os' => 'linux', 'osgi.ws' => 'gtk',    'osgi.arch' => 'x86_64',
                      'executable' => '$INSTALL_PATH/elexis',
                      'condition' => 'izpack.linuxinstall+is64bit', 
                      'description' => 'Linux (64-bit) abhängige Dateien'}
  Linux_x86      =  { 'osgi.os' => 'linux', 'osgi.ws' => 'gtk',    'osgi.arch' => 'x86',
                      'executable' => '$INSTALL_PATH/elexis',
                      'condition' => 'izpack.linuxinstall+is32bit', 
                      'description' => 'Linux (32-bit) abhängige Dateien'}
  Windows_x86_64 =  { 'osgi.os' => 'win32', 'osgi.ws' => 'win32',  'osgi.arch' => 'x86_64',
                      'executable' => '$INSTALL_PATH/elexis.exe',
                      'condition' => 'izpack.windowsinstall+is64bit', 
                      'description' => 'Windows (64-bit) abhängige Dateien'}
  Windows_x86    =  { 'osgi.os' => 'win32', 'osgi.ws' => 'win32',  'osgi.arch' => 'x86',
                      'executable' => '$INSTALL_PATH/elexis.exe',
                      'condition' => 'izpack.windowsinstall+is32bit', 
                      'description' => 'Windows (32-bit) abhängige Dateien'}
  
  platforms = [ Linux_x86_64, Linux_x86, Macosx_x86_64, Macosx_x86, Windows_x86_64, Windows_x86 ]
  product = EclipseExtension::readProductInfo(ProductInfoFile)
  allPacks = []
  
  # here we define the project which generates IzPack installers for all supported operations systems
  # using only plug-ins under a free (as in freedom) license
    jars = []
    baseProjects = [
      'ch.elexis.core',
      'ch.elexis.eigenartikel',
      'ch.elexis.h2.connector',
      'ch.elexis.importer.div',
      'ch.elexis',
      'ch.elexis.mysql.connector',
      'ch.elexis.postgresql.connector',
      'ch.elexis.scripting.beanshell',
      'ch.ngiger.elexis.branding',
      'ch.rgw.utility',
      'de.fhdo.elexis.perspective',
      'org.iatrix.help.wiki',
      ]
    kernPack = BuildrIzPack::Pack.new('Elexis-Kern', 'Elexis-Hauptprogramm', { 'required' => 'yes' })
    libPack = BuildrIzPack::Pack.new('Eclipse-Bibliotheken', 'Eclipse Bibliotheken, welche von Elexis Plug-Ins benutzt werden', { 'required' => 'yes' })
    baseProjects.each{ |x| kernPack.addFile(project(x).package(:plugin).to_s) }
    allPacks << kernPack
    allPacks << libPack
    chProjects = [
      'ch.elexis.arzttarife_ch',
      'ch.elexis.ebanking_ch',
      'ch.elexis.diagnosecodes_ch',
      'ch.elexis.labortarif.ch2009',
      'ch.elexis.artikel_ch',
    ]
    chPack = BuildrIzPack::Pack.new('Schweiz (deutsch)', 'Abrechnungs- und Diagnosesysteme Schweiz' )
    chProjects.each{ |x| chPack.addFile(project(x).package(:plugin).to_s) }
    allPacks << chPack
    oo2Projects = [] #  'ch.elexis.noatext' ]
    txtTemplProjects = [ 'ch.medelexis.text.templator' ]    
#    layout[:target, :main] = File.expand_path(File.join(_, '..', 'deploy', 'installer'))
    templatorPack = BuildrIzPack::Pack.new('Medelexis Text-Templator', 'Flexible Ausgabe für LibreOffice und andere Textprogramme' )
    txtTemplProjects.each{ |x| templatorPack.addFile(project(x).package(:plugin).to_s) }
    allPacks << templatorPack
    allProjects = (baseProjects + chProjects + oo2Projects + txtTemplProjects)
    allProjects.each {
      |proj|
	dependencies << project(proj)
	jars << project(proj).package(:plugin).to_s if project(proj).package(:plugin)
	project(proj).dependencies.each {|aDep| 
                                         jars << aDep if /.jar/.match(aDep.to_s) 
                                        }
    }
  
    file project._('target/rsc') do FileUtils.makedirs project._('target/rsc') end

    DemoDB = '2.1.5.4'
    demoZipFile = File.join(project._, 'rsc', "demoDB_elexis_#{DemoDB}.zip")
    download(demoZipFile => "http://ftp.medelexis.ch/downloads_opensource/elexis/demoDB/demoDB_elexis_#{DemoDB}.zip")
    file File.join(DeployElexis,'demoDB') => demoZipFile do
      cmd = "unzip -o -d #{DeployElexis} #{demoZipFile}"
      system(cmd) if !File.directory?(File.join(DeployElexis,'demoDB'))
    end
    task 'deploy' => [ demoZipFile, File.join(DeployElexis,'demoDB')] do
      FileUtils.makedirs(DeployElexis)
    end
    
    def getDefaultPlatform()
      values = { 'osgi.os' =>java.lang.System.get_property('os.name').downcase, 
		    'osgi.ws' => 'cocoa', 
		    'osgi.arch' => java.lang.System.get_property('os.arch')}
      case values['osgi.os']
	when /linux/i then
	  values['osgi.ws'] = 'gtk'
	when /win/i then
	  values['osgi.ws'] = 'win32'
	  values['osgi.os'] = 'win32'
      end
      values['osgi.arch'] = 'x86_64' if /amd64/.match(values['osgi.arch'])
      # trace "getDefaultPlatform returns #{values.inspect}"
      values
    end
    
    def platform2path(platformHash, separator=File::SEPARATOR)
      res = "#{platformHash['osgi.os']}#{separator}#{platformHash['osgi.ws']}#{separator}#{platformHash['osgi.arch']}"
    end

    def unpackPluginFromJar(jar, dest)
	  return if jar == nil # e.g. no macosx plugins when running under windows
      factName = jar
      destName = nil
      if File.exists?(jar)
	destName = File.join(dest, File.basename(jar).sub('.jar',''))
      else
	baseName = File.basename(artifact(jar).to_s)
	factName = File.join(ENV['OSGi'], 'plugins', baseName)
	destName = File.join(dest, baseName.sub('.jar',''))
      end
      puts "factName #{factName} #{File.exists?(factName)} => #{destName}"
      cmd = "unzip -o -d #{destName} #{factName}"
      p cmd
      system(cmd)
    end
    
    # Installs a plugin.
    # a) as a file copy if it is not a fragments
    # b) unpacks into a sub-directory if it is a fragment (or eclipse patch fragment)
    # c) for some reasons eclipse unpacks a plugin if there is no source statement in the build.properties
    def installPlugin(jar, destDir, defPlatform)
      jarname = jar.to_s
      destName = File.join(destDir, File.basename(jarname))
      destName.sub!(/-(\d)/,'_\1') if !jarname.index(ENV['OSGi']) # Match elexis-ant convention
      return if File.basename(jarname).index('.source_')
      return if FileUtils.uptodate?(destName, jarname)
      return if !EclipseExtension::jarMatchesPlatformFilter(jarname, defPlatform) 
      if EclipseExtension::isFragment(jarname) && !jarname.index('eclipse.swt') && !jarname.index('ui.cocoa')
	unpackPluginFromJar(jarname, destDir)  
      else
	FileUtils.makedirs(destDir)
	FileUtils.cp(jarname, destName, :verbose => Buildr.application.options.trace, :preserve=>true)
      end
    end
    # Find an artifact given by its name
    #   return jar if founc in the array of jars given (e.g. jar produced by project)
    #	return jar found as artifact (e.g. org.eclipse.ui)
    #	return jar found in OSGI (e.g. com.ibm.icu)
    # else raise an error
    #
    
    def getArtefactOrOsgiJar(jarname, defPlatform, jars = nil)
      if jars
	indexInJars = jars.index{|x|  x.class != String and x.id.eql?(jarname) }
	if indexInJars
	  trace "getArtefactOrOsgiJar found #{jarname} in jars #{jars[indexInJars].inspect}"
	  return jars[indexInJars]
	end
      end
      
      begin
	otherArtifact = artifact(jarname)
	if ! EclipseExtension::jarMatchesPlatformFilter(otherArtifact, defPlatform)
	  trace "getArtefactOrOsgiJar skipping 1 #{otherArtifact.to_s} #{defPlatform.inspect} for #{jarname}"
	  return nil 
	end
	trace "getArtefactOrOsgiJar found otherArtifact #{otherArtifact.to_s}  for #{jarname}"
	return otherArtifact
      rescue
      end

      fileName = File.join(ENV['OSGi'], 'plugins', "#{jarname}_*")
      files = Dir.glob(fileName)
      files.each{ |aFile|
	if EclipseExtension::jarMatchesPlatformFilter(aFile, defPlatform)
	  trace "getArtefactOrOsgiJar found file #{aFile.inspect} for #{jarname}"
	  return aFile
	end
      }
      trace "getArtefactOrOsgiJar nothing found for #{jarname}"
      trace "getArtefactOrOsgiJar:Check your buildfile. Could not find dependency #{jarname} specified in #{project.name}!"
    end
    
    # MacOSX need some special treatement!!
    def handleMacApp(destRoot, launcherName, initArgs)
      macApp    = File.join(destRoot, 'Eclipse.app')
      elexisApp = File.join(destRoot, launcherName +'.app')
      info "Macos #{macApp} -> #{elexisApp}"
      if File.exists?(macApp) then
	FileUtils.mv(macApp, elexisApp, :verbose => Buildr.application.options.trace)
	p Dir.glob("#{elexisApp}/**")
	p Dir.glob("#{elexisApp}/**/*")
	Dir.glob(File.join(elexisApp, '**/*')).each {
	  |x| 
	      dest = x.sub(/launcher/i,  launcherName)
	      dest.sub!(   /eclipse/i,  launcherName)
	      trace "macos found #{x} => #{dest} #{x.eql?(dest)}"
	      FileUtils.mv(x, dest, :verbose => Buildr.application.options.trace) if !x.eql?(dest)
	      }
      end
      infoPlist = File.join(elexisApp, 'Contents', 'Info.plist')
      inhalt = IO.readlines(infoPlist)
      toReplace = { '<string>eclipse</string>', '<string>'+ launcherName+'</string>',
                    '<string>Eclipse.icns</string>', '<string></string>',
                    '<string>Eclipse</string>', '<string>'+ launcherName+'</string>',
                    }
      inhalt.each { |x| toReplace.each { |from, to| x.sub!(from, to) } }
      File.open(infoPlist, 'w') {|f| f.write(inhalt) }                           
      File.open(File.join(elexisApp, 'Contents', 'MacOS', launcherName+'.ini'), 'w') {|f| f.write(initArgs) }                           
    end
    
    # Install the launcher exe, configuration, ini-files etc for the desired platform
    #
    def installLauncherAndConfiguration(destRoot, product, tgtPlatform, configIni=nil)
      tPlugins = File.join(destRoot, 'plugins')
      tConf    = File.join(destRoot, 'configuration')
      if !product['configIni'].eql?('default')
	raise "Don't know how to handle non default configIni section in product definition"
      end

      [tPlugins,tConf].each{ |d| FileUtils.makedirs(d) }
      
      Buildr::write(File.join(destRoot, '.eclipseproduct'),  %(#Eclipse Product File
# created by buildr.apache.org at #{Time.now}"
version=#{product['version'].sub('qualifier', EclipseExtension::Qualifier)}
name=#{product['uid']}
id=#{product['id']}
))
      # copy common launcher jar
      Dir.glob(File.join(ENV['OSGi'], 'plugins', "org.eclipse.equinox.launcher_*.jar")).each {
	|jarFile|
	  next if File.basename(jarFile).index('.source_')
	  next if !EclipseExtension::jarMatchesPlatformFilter(jarFile, tgtPlatform) 
	  subDir = File.join(tPlugins, File.basename(jarFile, '.jar'))
	  FileUtils.cp(jarFile, tPlugins, :verbose => Buildr.application.options.trace, :preserve => true) 
      }
      # unpack correct os specific launcher jar
      Dir.glob(File.join(ENV['OSGi'], 'plugins', "org.eclipse.equinox.launcher.*.jar")).each {
	|jarFile|
	  next if File.basename(jarFile).index('.source_')
	  next if !EclipseExtension::jarMatchesPlatformFilter(jarFile, tgtPlatform) 
	  subDir = File.join(tPlugins, File.basename(jarFile, '.jar'))
	  unzipper =  Buildr::Unzip.new(subDir=>jarFile)
	  unzipper.extract
      }
      # Copy equinox executable
      execJar = Dir.glob(File.join(ENV['OSGi'], 'features', 'org.eclipse.equinox.executable_*jar'))[0]
      # Unzip common stuff (license)
      unzipper =  Buildr::Unzip.new(tPlugins =>execJar)
      unzipper.from_path(".").include('*')
      unzipper.extract
	
      # Unzip graphical toolkit specific stuff
      unzipper =  Buildr::Unzip.new(destRoot =>execJar)
      unzipper.from_path("#{tgtPlatform['osgi.ws']}_root").include('**')
      unzipper.extract
      
      # Unzip os specific stuff
      unzipper =  Buildr::Unzip.new(destRoot =>execJar)
      unzipper.from_path("bin/#{platform2path(tgtPlatform)}").include('*')
      p unzipper
      unzipper.extract
      
      # Here Eclipse uses ws/os/arch instead of ow/ws/arch in other places (.e.g, destination of install!!)
      pathName = File.join(ENV['OSGi'], 'features', 'org.eclipse.equinox.executable_*', 'bin',
                           tgtPlatform['osgi.ws'],  tgtPlatform['osgi.os'], tgtPlatform['osgi.arch'], '**')
      Dir.glob(pathName).each{
	|x|
	  next if File.basename(x).eql?('eclipsec.exe')
	  if File.basename(x).eql?('launcher') || File.basename(x).eql?('launcher.exe')
	    tgt = File.join(destRoot, File.basename(x))
	    tgt.gsub!('launcher', product['launcher'])
	    FileUtils.cp_r(x, tgt, :verbose => Buildr.application.options.trace, :preserve => true)
	    FileUtils.chmod(0755, tgt)
	  else
	    FileUtils.cp_r(x, destRoot, :verbose => Buildr.application.options.trace, :preserve => true)
	  end
      }
-      configIni = %(#Product Runtime Configuration File 
# created by buildr.apache.org at #{Time.now}"
eclipse.application=#{product['application']}
osgi.bundles.defaultStartLevel=4
eclipse.product=#{product['id']}
osgi.splashPath=platform:/base/plugins/#{product['splash']}
osgi.bundles=org.eclipse.equinox.common@2:start,org.eclipse.update.configurator@3:start,org.eclipse.core.runtime@start
) if configIni == nil
       
      Buildr::write(File.join(tConf, 'config.ini'), configIni)
      
      # Add config argument
      initArgs  = ''
      initArgs << product['programArgs'] if product['programArgs']
      initArgs << ' -vmargs ' + product['vmArgs'] if product['vmArgs']
      initArgs << ' ' + product['vmArgsMac']   if (tgtPlatform['osgi.os'] && /macosx/.match(tgtPlatform['osgi.os']) != nil && product['vmArgsMac'])
      initArgs = initArgs.split(' ').join("\n")
      initArgs << "\n"
      if /macosx/.match(tgtPlatform['osgi.os'])
	handleMacApp(destRoot,  product['launcher'], initArgs)
      else
	Buildr::write(File.join(destRoot, product['launcher']+'.ini'), initArgs)      
      end
      
      
    end
    
    
    # target platform see also http://eclipse.dzone.com/articles/simplifying-p2f-process-part-2
    # Übersicht Build-Systeme für Eclipse http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CCoQFjAA&url=http%3A%2F%2Fwww.nilshartmann.net%2Ffiles%2FBuild_my_bundle.pdf&ei=7us8T8H5H4S0-QaZwNDJBQ&usg=AFQjCNHMXqO66-oZ7pwuj4h_JEOI673_Ow
    # oRsc  = File.expand_path(File.join(project._, '..', '..', 'elexis-base', 'BuildElexis', 'rsc'))
    pRsc  = File.expand_path(File.join(project._, 'rsc'))
    files = Dir.glob(File.join(pRsc, '*.textile'))
    htmlFiles = []
    files.each do |src|
      htmlFile = File.join(pRsc, "#{File.basename(src, '.textile')}.html")
      desc 'Create opensource installers'
      task 'izpack' => htmlFile
      htmlFiles << htmlFile
      file htmlFile => src do  Wikitext::HtmlFromTextile(htmlFile, src) end
    end if files.size > 0
    
    # What we want:
    # Copy all common stuff from ../elexis-base/BuildElexis/rsc into _+'rsc'  e.g. *.html, i18n
    # Copy specific elexis.<os> from ../elexis-base/BuildElexis/rsc/os into _+'target/{os}/rsc'
    # the copy also all _+'rsc' into  _+'target/{os}' , eg. demoDB, deps/*.jar
    # We use the following variables
    # pRsc   ch.ngiger.elexis.opensource/rsc
    # izRsc   ch.ngiger.elexis.opensource/target/rsc
    # tRsc   ch.ngiger.elexis.opensource/target/rsc/#{os}
    allProjects.each { |proj| task 'izpack' => project(proj).package(:plugin); dependencies << proj }
    osPath = File.join(project.path_to(:target), 'os')
    izRsc = File.join(project.path_to(:target), 'rsc')
    dest = project.path_to(:target, "elexis-#{version}-installer.jar")
    installerConfigIni = %(#Product Runtime Configuration File
# created by buildr.apache.org at #{Time.now}"
eclipse.application=#{product['application']}
osgi.bundles.defaultStartLevel=4
eclipse.product=#{product['id']}
osgi.splashPath=platform:/base/plugins/#{product['splash']}
osgi.bundles=org.eclipse.core.runtime@start,org.eclipse.equinox.common@2:start,org.eclipse.update.configurator@3:start
osgi.nl=de_CH
osgi.instance.area=@user.home/.elexis.workspace
osgi.configuration.area=@user.home/.elexis.configuration
eclipse.vmargs=-XX:PermSize=126M -XX:MaxPermSize=257M 
)
    
    allJars = []
    allCommonJars = []
    platforms.each {
      |tgtPlatform|
	  jars2copy = []
	  tgtPlatform['os_files'] = []
	(product['plugins'] + product['fragments']).each { |aRef|
							  arte = getArtefactOrOsgiJar(aRef.to_s, tgtPlatform, jars)
							  if arte == nil
							    trace "No arte for #{aRef.to_s}"
							    next
							  end
                                                          next if arte.to_s.index('.source_')
							  jars2copy << arte
							  allJars << arte
                                                          if EclipseExtension::getPlatformFilter(arte)
                                                            tgtPlatform['os_files'] << arte
                                                          else
                                                            allCommonJars << arte 
                                                         end
							}
	jars2copy.each{ |jar| task dest => jar }
	package.enhance do
	  tRsc    = File.join(osPath, platform2path(tgtPlatform,'.'))
	  tgtPlatform['os_specific'] = tRsc
	  destRoot = File.join(project.path_to(:target), platform2path(tgtPlatform, '.'))
	  FileUtils.makedirs(tRsc)
	  FileUtils.makedirs(File.join(destRoot, 'plugins'))
	  product = EclipseExtension::readProductInfo(ProductInfoFile)
	  installLauncherAndConfiguration(tRsc, product, tgtPlatform, installerConfigIni)
	  # OS specific part for the launcher
	  FileUtils.cp_r(tRsc, File.dirname(destRoot), :verbose => true)
	  jars2copy.uniq.each{ 
	    |jar|
	      installPlugin(jar.to_s, File.join(destRoot, 'plugins'), tgtPlatform) 
	  } 
      end
    }
    
    htmlFiles.each{ |x| 
		    file File.join(izRsc, File.basename(x)) => x do
		      FileUtils.makedirs(izRsc)
		      FileUtils.cp(x,    izRsc, :verbose => Buildr.application.options.trace)
		      # kernPack.addFile(x, File.join('$INSTALLATION_PATH', 'docs', File.basename(x)))
		    end if File.expand_path(File.dirname(x)) != izRsc
		    task dest => [x, File.join(izRsc, File.basename(x))] 
		  }
                                    
    package.enhance do
      puts "defining Task izpack"
      FileUtils.makedirs(path_to(:target), :verbose => true) if !File.directory?(path_to(:target))
      tgtPanel = File.join(path_to(:target), 'TargetPanel.txt')
      Buildr::write(tgtPanel, "$SYSTEM_user_home/Elexis/bin/Elexis-#{project.version}")
      myInstXml = File.join(path_to(:target), 'installer.xml')
      allCommonJars.each{ |x| p x; libPack.addFile(x.to_s) }
				    
      xm = Builder::XmlMarkup.new(:target=>File.open(myInstXml, 'w+'), :indent => 2)
      xm.instruct!
      xm.installation('version'=>'1.0') {
	xm.tag!('info') { xm.appversion(project.version); xm.appname(project.name) }
	xm.guiprefs('width' => '800', 'height' => '600', 'resizable' => 'yes')
	xm.panels { |x| xm.panel('classname' => 'HTMLInfoPanel') 
			xm.panel('classname' => 'HTMLLicencePanel') 
			xm.panel('classname' => 'TargetPanel') 
			xm.panel('classname' => 'PacksPanel') 
			xm.panel('classname' => 'InstallPanel') 
			xm.panel('classname' => 'ShortcutPanel') 
			xm.panel('classname' => 'FinishPanel') 

		    }
	xm.locale { |x| xm.langpack('iso3'=>'eng'); xm.langpack('iso3'=>'deu'); xm.langpack('iso3'=>'fra') }
	xm.native('type' => 'izpack', 'name' => 'ShellLink.dll')
	  xm.conditions { |j| 
	    xm.condition('type' => 'variable', 'id'=>'is32bit') { |x| xm.name('SYSTEM_sun_arch_data_model'); xm.value('32') } 
	    xm.condition('type' => 'variable', 'id'=>'is64bit') { |x| xm.name('SYSTEM_sun_arch_data_model'); xm.value('64') }
			}
	xm.resources{ |x|
		      xm.res('id' =>'TargetPanel.dir', 'src' => tgtPanel)
		      xm.res('id' =>'BSFActionsSpec.xml', 'src' => _('rsc/BSFActionsSpec.xml'))
		      xm.res('id' =>'copyConfiguration.bsh', 'src' => _('rsc/copyConfiguration.bsh'))
		      xm.res('id' =>'unzipDemoDB.bsh', 'src' => _('rsc/unzipDemoDB.bsh'))
		      xm.res('id' =>'packsLang.xml_eng', 'src' => _('rsc/i18n/packsLang.xml_eng'))
		      xm.res('id' =>'packsLang.xml_fra', 'src' => _('rsc/i18n/packsLang.xml_fra'))
		      xm.res('id' =>'HTMLLicencePanel.licence', 'src' => _('rsc/license.html'))
		      xm.res('id' =>'HTMLInfoPanel.info', 'src' => _('rsc/info.html'), 'parse'=>'yes', 'type'=>'xml')
		      xm.res('id' =>'HTMLInfoPanel.info_fra', 'src' => _('rsc/info_fra.html'), 'parse'=>'yes', 'type'=>'xml')
		      xm.res('id' =>'HTMLInfoPanel.info_eng', 'src' => _('rsc/info_eng.html'), 'parse'=>'yes', 'type'=>'xml')
		      xm.res('id' =>'medelexis-logo.png', 'src' => _('rsc/elexis-logo.png'))
		      xm.res('id' =>'Win_shortcutSpec.xml', 'src' => _('rsc/Shortcuts_Windows.xml'))
		      xm.res('id' =>'Unix_shortcutSpec.xml', 'src' => _('rsc/Shortcuts_Linux.xml'))
		      }
	xm.jar('src' => _('rsc/deps/apache/commons-logging/1.1.1/commons-logging-1.1.1.jar'), 'stage' => 'both')
	xm.jar('src' => _('rsc/deps/bsh/bsh/2.0b4/bsh-2.0b4.jar'), 'stage' => 'both')
	xm.jar('src' => _('rsc/deps/apache/bsf/2.4.0/bsf-2.4.0.jar'), 'stage' => 'both')
	xm.jar('src' => _('rsc/deps/apache/commons-io/1.4/commons-io-1.4.jar'), 'stage' => 'both')
	xm.listeners{ |x| xm.listener('installer' => 'BSFInstallerListener', 'uninstaller' => 'BSFUninstallerListener') }
	xm.summarylogfilepath('$INSTALL_PATH/Uninstaller/MySummary.htm')
	xm.packs {
	xm.pack('name' => 'demoDB', 'required' => 'no', 'preselected'=>'no') {
	  xm.description('DemoDB. Nützlich, um Elexis kennen zu lernen.')
	  xm.file('src'=> demoZipFile, 'targetdir' =>'$INSTALL_PATH/demoDB/'+File.basename(demoZipFile))
				    }
	  allPacks.each { |aPack| aPack.emitIzPackXML(xm) }
	  platforms.each { |tgtPlatform|
	    tRsc    = tgtPlatform['os_specific']
	    xm.pack('name' =>platform2path(tgtPlatform,'.'), 'condition'=>tgtPlatform['condition'], 'required' => 'yes') {
	    |x| xm.description(tgtPlatform['description'])
		xm.executable('targetfile' => tgtPlatform['executable'], 'keep' => 'true')
		xm.singlefile('src' => tgtPanel, 'target' => "$INSTALL_PATH/#{tgtPlatform['condition']}")
		tgtPlatform['os_files'].each { |jar| xm.singlefile('src' => jar, 'target' => jar.sub(File.dirname(jar), '$INSTALL_PATH/plugins')) }
		Dir.glob(File.join(tRsc, '**', '*')).each { |fileOrDir|
			next if File.directory?(fileOrDir)
			xm.singlefile('src' => fileOrDir, 'target' =>  fileOrDir.sub(tRsc, '$INSTALL_PATH'))
		}
	      }
	    }
	  }
	}
				  
      xm.target!().close
      package(:jar)
      # It is you responsability to specify correctly all dependencies!!
      package(:izpack).input = myInstXml
      package(:izpack).izpackVersion = '4.3.1'
end
	    
task 'izpack' =>  package do 
  package(:izpack).include(allCommonJars)
  package(:izpack).invoke 
end
     