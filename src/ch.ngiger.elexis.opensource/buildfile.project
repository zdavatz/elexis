#!/usr/bin/ruby 
# encoding: utf-8
# Copyright 2012 by Niklaus Giger <niklaus.giger@member.fsf.org
#
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Delta pack from http://mirror.switch.ch/eclipse/eclipse/downloads/drops/R-3.7.2-201202080800/eclipse-3.7.2-delta-pack.zip
# See also http://aniefer.blogspot.com/2009/06/using-deltapack-in-eclipse-35.html
# The director is only able to install for one platform so it can't really handle the delta pack. You should instead look at using a combination of the p2.mirror and p2.repo2runnable ant tasks which don't care about the platform. 
# ./eclipse -nosplash -consolelog -application org.eclipse.equinox.p2.repository.repo2runnable \
#   -source jar:file:/home/nboldt/eclipse/35clean/GEF-Update-3.5.0RC2.zip\!/ \
#   -source GEF-Update-N200905281802/
#   -source emf-sdo-xsd-Update-2.4.2.zip
#   -source http://download.eclipse.org/tools/ve/updates/1.4
#   -destination /tmp/unpacked

# we should parse Eclipse-PlatformFilter: (& (osgi.ws=win32) (osgi.os=win32) (osgi.arch= x86_64))
Java.load # needed to load class path for apache logger
#  DeployElexis = File.expand_path(File.join(project(group)._, '..', 'deploy'))
  DeployElexis = File.expand_path(File.join(Dir.pwd, 'deploy'))
  layout[:target] = DeployElexis
  ProductInfoFile = _('branding.product')
  Macosx_x86_64  =  { 'osgi.os' => 'macosx', 'osgi.ws' => 'cocoa', 'osgi.arch' => 'x86_64'}
  Macosx_x86     =  { 'osgi.os' => 'macosx', 'osgi.ws' => 'cocoa', 'osgi.arch' => 'x86'}
  Linux_x86_64   =  { 'osgi.os' => 'linux', 'osgi.ws' => 'gtk',    'osgi.arch' => 'x86_64'}
  Linux_x86      =  { 'osgi.os' => 'linux', 'osgi.ws' => 'gtk',    'osgi.arch' => 'x86'}
  Windows_x86_64 =  { 'osgi.os' => 'win32', 'osgi.ws' => 'win32',  'osgi.arch' => 'x86_64'}
  Windows_x86    =  { 'osgi.os' => 'win32', 'osgi.ws' => 'win32',  'osgi.arch' => 'x86'}
  
  platforms = [ Linux_x86_64, Linux_x86, Macosx_x86_64, Macosx_x86, Windows_x86_64, Windows_x86 ]
  product = EclipseExtension::readProductInfo(ProductInfoFile)
                                                     
  # here we define the project which generates IzPack installers for all supported operations systems
  # using only plug-ins under a free (as in freedom) license
    jars = []
    baseProjects = [
      'ch.elexis.core',
      'ch.elexis.eigenartikel',
      'ch.elexis.h2.connector',
      'ch.elexis.importer.div',
      'ch.elexis',
      'ch.elexis.mysql.connector',
      'ch.elexis.postgresql.connector',
      'ch.elexis.scripting.beanshell',
      'ch.ngiger.elexis.branding',
      'ch.rgw.utility',
      'de.fhdo.elexis.perspective',
      'org.iatrix.help.wiki',
      ]
    chProjects = [
      'ch.elexis.arzttarife_ch',
      'ch.elexis.ebanking_ch',
      'ch.elexis.diagnosecodes_ch',
      'ch.elexis.labortarif.ch2009',
      'ch.elexis.artikel_ch',
    ]
    oo2Projects = [] #  'ch.elexis.noatext' ]
    txtTemplProjects = [ 'ch.medelexis.text.templator' ]    
#    layout[:target, :main] = File.expand_path(File.join(_, '..', 'deploy', 'installer'))
    
    (baseProjects + chProjects + oo2Projects + txtTemplProjects).each {
      |proj|
	dependencies << project(proj)
	jars << project(proj).package(:plugin) if project(proj).package(:plugin)
	project(proj).dependencies.each {|aDep| 
                                         jars << aDep if /.jar/.match(aDep.to_s) 
                                        }
    }
  
    file project._('target/rsc') do FileUtils.makedirs project._('target/rsc') end

    DemoDB = '2.1.5.4'
    demoZipFile = File.join(project._, 'rsc', "demoDB_elexis_#{DemoDB}.zip")
    download(demoZipFile => "http://ftp.medelexis.ch/downloads_opensource/elexis/demoDB/demoDB_elexis_#{DemoDB}.zip")
    file File.join(DeployElexis,'demoDB') => demoZipFile do
      cmd = "unzip -o -d #{DeployElexis} #{demoZipFile}"
      system(cmd) if !File.directory?(File.join(DeployElexis,'demoDB'))
    end
    task 'deploy' => [ demoZipFile, File.join(DeployElexis,'demoDB')] do
      FileUtils.makedirs(DeployElexis)
    end
    
    def getDefaultPlatform()
      values = { 'osgi.os' =>java.lang.System.get_property('os.name').downcase, 
		    'osgi.ws' => 'cocoa', 
		    'osgi.arch' => java.lang.System.get_property('os.arch')}
      case values['osgi.os']
	when /linux/i then
	  values['osgi.ws'] = 'gtk'
	when /win/i then
	  values['osgi.ws'] = 'win32'
	  values['osgi.os'] = 'win32'
      end
      values['osgi.arch'] = 'x86_64' if /amd64/.match(values['osgi.arch'])
      # trace "getDefaultPlatform returns #{values.inspect}"
      values
    end
    
    def platform2path(platformHash, separator=File::SEPARATOR)
      res = "#{platformHash['osgi.os']}#{separator}#{platformHash['osgi.ws']}#{separator}#{platformHash['osgi.arch']}"
    end

    def unpackPluginFromJar(jar, dest)
	  return if jar == nil # e.g. no macosx plugins when running under windows
      factName = jar
      destName = nil
      if File.exists?(jar)
	destName = File.join(dest, File.basename(jar).sub('.jar',''))
      else
	baseName = File.basename(artifact(jar).to_s)
	factName = File.join(ENV['OSGi'], 'plugins', baseName)
	destName = File.join(dest, baseName.sub('.jar',''))
      end
      puts "factName #{factName} #{File.exists?(factName)} => #{destName}"
      cmd = "unzip -o -d #{destName} #{factName}"
      p cmd
      system(cmd)
    end
    
    # Installs a plugin.
    # a) as a file copy if it is not a fragments
    # b) unpacks into a sub-directory if it is a fragment (or eclipse patch fragment)
    # c) for some reasons eclipse unpacks a plugin if there is no source statement in the build.properties
    def installPlugin(jar, destDir, defPlatform)
      jarname = jar.to_s
      destName = File.join(destDir, File.basename(jarname))
      destName.sub!(/-(\d)/,'_\1') if !jarname.index(ENV['OSGi']) # Match elexis-ant convention
      return if File.basename(jarname).index('.source_')
      return if FileUtils.uptodate?(destName, jarname)
      return if !EclipseExtension::jarMatchesPlatformFilter(jarname, defPlatform) 
      if EclipseExtension::isFragment(jarname) && !jarname.index('eclipse.swt') && !jarname.index('ui.cocoa')
	unpackPluginFromJar(jarname, destDir)  
      else
	FileUtils.makedirs(destName)
	FileUtils.cp(jarname, destName, :verbose => Buildr.application.options.trace, :preserve=>true)
      end
    end
    # Find an artifact given by its name
    #   return jar if founc in the array of jars given (e.g. jar produced by project)
    #	return jar found as artifact (e.g. org.eclipse.ui)
    #	return jar found in OSGI (e.g. com.ibm.icu)
    # else raise an error
    #
    
    def getArtefactOrOsgiJar(jarname, defPlatform, jars = nil)
      if jars
	indexInJars = jars.index{|x|  x.class != String and x.id.eql?(jarname) }
	if indexInJars
	  trace "getArtefactOrOsgiJar found #{jarname} in jars #{jars[indexInJars].inspect}"
	  return jars[indexInJars]
	end
      end
      
      begin
	otherArtifact = artifact(jarname)
	if ! EclipseExtension::jarMatchesPlatformFilter(otherArtifact, defPlatform)
	  trace "getArtefactOrOsgiJar skipping 1 #{otherArtifact.to_s} #{defPlatform.inspect} for #{jarname}"
	  return nil 
	end
	trace "getArtefactOrOsgiJar found otherArtifact #{otherArtifact.to_s}  for #{jarname}"
	return otherArtifact
      rescue
      end

      fileName = File.join(ENV['OSGi'], 'plugins', "#{jarname}_*")
      files = Dir.glob(fileName)
      files.each{ |aFile|
	if EclipseExtension::jarMatchesPlatformFilter(aFile, defPlatform)
	  trace "getArtefactOrOsgiJar found file #{aFile.inspect} for #{jarname}"
	  return aFile
	end
      }
      trace "getArtefactOrOsgiJar nothing found for #{jarname}"
      trace "getArtefactOrOsgiJar:Check your buildfile. Could not find dependency #{jarname} specified in #{project.name}!"
    end
    
    # MacOSX need some special treatement!!
    def handleMacApp(destRoot, launcherName, initArgs)
      macApp    = File.join(destRoot, 'Eclipse.app')
      elexisApp = File.join(destRoot, launcherName +'.app')
      info "Macos #{macApp} -> #{elexisApp}"
      if File.exists?(macApp) then
	FileUtils.mv(macApp, elexisApp, :verbose => Buildr.application.options.trace)
	p Dir.glob("#{elexisApp}/**")
	p Dir.glob("#{elexisApp}/**/*")
	Dir.glob(File.join(elexisApp, '**/*')).each {
	  |x| 
	      dest = x.sub(/launcher/i,  launcherName)
	      dest.sub!(   /eclipse/i,  launcherName)
	      trace "macos found #{x} => #{dest} #{x.eql?(dest)}"
	      FileUtils.mv(x, dest, :verbose => Buildr.application.options.trace) if !x.eql?(dest)
	      }
      end
      infoPlist = File.join(elexisApp, 'Contents', 'Info.plist')
      inhalt = IO.readlines(infoPlist)
      toReplace = { '<string>eclipse</string>', '<string>'+ launcherName+'</string>',
                    '<string>Eclipse.icns</string>', '<string></string>',
                    '<string>Eclipse</string>', '<string>'+ launcherName+'</string>',
                    }
      inhalt.each { |x| toReplace.each { |from, to| x.sub!(from, to) } }
      File.open(infoPlist, 'w') {|f| f.write(inhalt) }                           
      File.open(File.join(elexisApp, 'Contents', 'MacOS', launcherName+'.ini'), 'w') {|f| f.write(initArgs) }                           
    end
    
    # Install the launcher exe, configuration, ini-files etc for the desired platform
    #
    def installLauncherAndConfiguration(destRoot, product, tgtPlatform, configIni=nil)
      tPlugins = File.join(destRoot, 'plugins')
      tConf    = File.join(destRoot, 'configuration')
      if !product['configIni'].eql?('default')
	raise "Don't know how to handle non default configIni section in product definition"
      end

      [tPlugins,tConf].each{ |d| FileUtils.makedirs(d) }
      
      Buildr::write(File.join(destRoot, '.eclipseproduct'),  %(#Eclipse Product File
# created by buildr.apache.org at #{Time.now}"
version=#{product['version'].sub('qualifier', EclipseExtension::Qualifier)}
name=#{product['uid']}
id=#{product['id']}
))
      # copy common launcher jar
      Dir.glob(File.join(ENV['OSGi'], 'plugins', "org.eclipse.equinox.launcher_*.jar")).each {
	|jarFile|
	  next if File.basename(jarFile).index('.source_')
	  next if !EclipseExtension::jarMatchesPlatformFilter(jarFile, tgtPlatform) 
	  subDir = File.join(tPlugins, File.basename(jarFile, '.jar'))
	  FileUtils.cp(jarFile, tPlugins, :verbose => Buildr.application.options.trace, :preserve => true) 
      }
      # unpack correct os specific launcher jar
      Dir.glob(File.join(ENV['OSGi'], 'plugins', "org.eclipse.equinox.launcher.*.jar")).each {
	|jarFile|
	  next if File.basename(jarFile).index('.source_')
	  next if !EclipseExtension::jarMatchesPlatformFilter(jarFile, tgtPlatform) 
	  subDir = File.join(tPlugins, File.basename(jarFile, '.jar'))
	  unzipper =  Buildr::Unzip.new(subDir=>jarFile)
	  unzipper.extract
      }
      # Copy equinox executable
      execJar = Dir.glob(File.join(ENV['OSGi'], 'features', 'org.eclipse.equinox.executable_*jar'))[0]
      # Unzip common stuff (license)
      unzipper =  Buildr::Unzip.new(tPlugins =>execJar)
      unzipper.from_path(".").include('*')
      unzipper.extract
	
      # Unzip graphical toolkit specific stuff
      unzipper =  Buildr::Unzip.new(destRoot =>execJar)
      unzipper.from_path("#{tgtPlatform['osgi.ws']}_root").include('**')
      unzipper.extract
      
      # Unzip os specific stuff
      unzipper =  Buildr::Unzip.new(destRoot =>execJar)
      unzipper.from_path("bin/#{platform2path(tgtPlatform)}").include('*')
      p unzipper
      unzipper.extract
      
      # Here Eclipse uses ws/os/arch instead of ow/ws/arch in other places (.e.g, destination of install!!)
      pathName = File.join(ENV['OSGi'], 'features', 'org.eclipse.equinox.executable_*', 'bin',
                           tgtPlatform['osgi.ws'],  tgtPlatform['osgi.os'], tgtPlatform['osgi.arch'], '**')
      Dir.glob(pathName).each{
	|x|
	  next if File.basename(x).eql?('eclipsec.exe')
	  if File.basename(x).eql?('launcher') || File.basename(x).eql?('launcher.exe')
	    tgt = File.join(destRoot, File.basename(x))
	    tgt.gsub!('launcher', product['launcher'])
	    FileUtils.cp_r(x, tgt, :verbose => Buildr.application.options.trace, :preserve => true)
	    FileUtils.chmod(0755, tgt)
	  else
	    FileUtils.cp_r(x, destRoot, :verbose => Buildr.application.options.trace, :preserve => true)
	  end
      }
-      configIni = %(#Product Runtime Configuration File 
# created by buildr.apache.org at #{Time.now}"
eclipse.application=#{product['application']}
osgi.bundles.defaultStartLevel=4
eclipse.product=#{product['id']}
osgi.splashPath=platform:/base/plugins/#{product['splash']}
osgi.bundles=org.eclipse.equinox.common@2:start,org.eclipse.update.configurator@3:start,org.eclipse.core.runtime@start
) if configIni == nil
       
      Buildr::write(File.join(tConf, 'config.ini'), configIni)
      
      # Add config argument
      initArgs  = ''
      initArgs << product['programArgs'] if product['programArgs']
      initArgs << ' -vmargs ' + product['vmArgs'] if product['vmArgs']
      initArgs << ' ' + product['vmArgsMac']   if (tgtPlatform['osgi.os'] && /macosx/.match(tgtPlatform['osgi.os']) != nil && product['vmArgsMac'])
      initArgs = initArgs.split(' ').join("\n")
      initArgs << "\n"
      if /macosx/.match(tgtPlatform['osgi.os'])
	handleMacApp(destRoot,  product['launcher'], initArgs)
      else
	Buildr::write(File.join(destRoot, product['launcher']+'.ini'), initArgs)      
      end
      
      
    end
    
    
    # target platform see also http://eclipse.dzone.com/articles/simplifying-p2f-process-part-2
    # Übersicht Build-Systeme für Eclipse http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CCoQFjAA&url=http%3A%2F%2Fwww.nilshartmann.net%2Ffiles%2FBuild_my_bundle.pdf&ei=7us8T8H5H4S0-QaZwNDJBQ&usg=AFQjCNHMXqO66-oZ7pwuj4h_JEOI673_Ow
    # oRsc  = File.expand_path(File.join(project._, '..', '..', 'elexis-base', 'BuildElexis', 'rsc'))
    pRsc  = File.expand_path(File.join(project._, 'rsc'))
    files = Dir.glob(File.join(pRsc, '*.textile'))
    htmlFiles = []
    files.each do |src|
      htmlFile = File.join(pRsc, "#{File.basename(src, '.textile')}.html")
      desc 'Create opensource installers'
      task 'izpack' => htmlFile
      htmlFiles << htmlFile
      file htmlFile => src do  Wikitext::HtmlFromTextile(htmlFile, src) end
    end if files.size > 0
    
    # What we want:
    # Copy all common stuff from ../elexis-base/BuildElexis/rsc into _+'rsc'  e.g. *.html, i18n
    # Copy specific elexis.<os> from ../elexis-base/BuildElexis/rsc/os into _+'target/{os}/rsc'
    # the copy also all _+'rsc' into  _+'target/{os}' , eg. demoDB, deps/*.jar
    # We use the following variables
    # pRsc   ch.ngiger.elexis.opensource/rsc
    # izRsc   ch.ngiger.elexis.opensource/target/rsc
    # tRsc   ch.ngiger.elexis.opensource/target/rsc/#{os}
    allProjects.each { |proj| task 'izpack' => project(proj).package(:plugin); dependencies << proj }
    osPath = File.join(project.path_to(:target), 'os')
    izRsc = File.join(project.path_to(:target), 'rsc')
    dest = project.path_to(:target, "elexis-#{version}-installer.jar")
    installerConfigIni = %(#Product Runtime Configuration File
# created by buildr.apache.org at #{Time.now}"
eclipse.application=#{product['application']}
osgi.bundles.defaultStartLevel=4
eclipse.product=#{product['id']}
osgi.splashPath=platform:/base/plugins/#{product['splash']}
osgi.bundles=org.eclipse.core.runtime@start,org.eclipse.equinox.common@2:start,org.eclipse.update.configurator@3:start
osgi.nl=de_CH
osgi.instance.area=@user.home/.elexis.workspace
osgi.configuration.area=@user.home/.elexis.configuration
eclipse.vmargs=-XX:PermSize=126M -XX:MaxPermSize=257M 
)
    
    platforms.each {
      |tgtPlatform|
	  jars2copy = []
	(product['plugins'] + product['fragments']).each { |aRef|
							  arte = getArtefactOrOsgiJar(aRef.to_s, tgtPlatform, jars)
							  if arte == nil
							    trace "No arte for #{aRef.to_s}"
							    next
							  end
							  jars2copy << arte
							} 
	
	jars2copy.uniq.each{ |jar| task dest => jar }
	package.enhance do
	  tRsc    = File.join(osPath, platform2path(tgtPlatform,'.'))
	  destRoot = File.join(project.path_to(:target), platform2path(tgtPlatform, '.'))
	  FileUtils.makedirs(tRsc)
	  FileUtils.makedirs(File.join(destRoot, 'plugins'))
	  product = EclipseExtension::readProductInfo(ProductInfoFile)
	  installLauncherAndConfiguration(tRsc, product, tgtPlatform, installerConfigIni)
	  # OS specific part for the launcher
	  FileUtils.cp_r(tRsc, File.dirname(destRoot), :verbose => true)
	  jars2copy.uniq.each{ 
	    |jar|
	      installPlugin(jar.to_s, File.join(destRoot, 'plugins'), tgtPlatform) 
	  }
      end
    }
    
    task izRsc => [ pRsc, demoZipFile] do
      FileUtils.cp(demoZipFile, izRsc, :verbose => Buildr.application.options.trace, :preserve => true) 
      FileUtils.cp_r(Dir.glob(File.join(pRsc, '*')), izRsc, :verbose => Buildr.application.options.trace,   :preserve=>true)
      Buildr::write(File.join(izRsc, 'TargetPanel.txt'), "$SYSTEM_user_home/Elexis/bin/Elexis-#{project.version}")
      system("echo '#{izRsc}' && ls -l #{File.join(izRsc, 'TargetPanel.txt')} ")
    end
    htmlFiles.each{ |x| 
		    file File.join(izRsc, File.basename(x)) => x do
		      FileUtils.makedirs(izRsc)
		      FileUtils.cp(x,    izRsc, :verbose => Buildr.application.options.trace)
		    end if File.expand_path(File.dirname(x)) != izRsc
		    task dest => [x, File.join(izRsc, File.basename(x))] 
		  }
	  
    task dest => [osPath, izRsc] do
      izpackProperties = Hash.new
      izpackProperties['osPath'] = osPath
      task osPath do FileUtils.makedirs(osPath) end
      genIzPack(dest, _('installer.xml'), jars,  File.dirname(dest), izpackProperties)
    end
    task 'izpack' => [package, dest]
    